'''
port scanning automation tool used on the command line
1) run a port scan on all ports
input: ip address
output:
    a) list of open ports to scan further
    b) list of filtered ports to scan further to use
2) run an nmap version scan against ports found to use
input:  list of open ports
output:
    a) print dictionary of results (i.e. port : [service, version, vulns])
    b) list of versions to use
3) use searchsploit to find vulnerabilities based on version used
input: list of versions
output: print dictionary of possible vulnerabilities (i.e. version : [vuln1, ...])
*** this is like scanner_v2.py (version 2), but use a Port class to keep track of ports and add information as you go
'''
# modules required
import sys
import os
import subprocess
import xml.etree.ElementTree
import pprint
import json


class Port:
    ''' a class for each Port found in a port scan '''

    def __init__(self, portid, transport_protocol, state, service):
        self.portid = portid
        self.transport_protocol = transport_protocol
        self.state = state
        self.service = service
        self.vulnerabilities = {}

    def __str__(self):
        return self.portid

    def __repr__(self):
        return '{} : {}'.format(self.portid, self.service['name'])


class Target:
    ''' a class for each Target of a port scan '''
    # separator value to use when printing output
    sep = '=' * 60

    def __init__(self, ip):
        self.ip = ip
        self.ports = []
        self.os = ''

    def getPorts(self):
        ''' run an nmap TCP port scan on all ports for given ip address '''
        # create a xml file to parse for results
        scanfile = '/tmp/temp.xml'
        # create a subprocess and run nmap command
        scan = subprocess.call(
            'nmap -T4 -p- {} -oX {} > /dev/null'.format(ip, scanfile), shell=True)
        # parse temp xml file
        tree = xml.etree.ElementTree.parse(scanfile)
        # create a list of port objects
        ports = []
        # remove temporary xml file created (cleanup)
        os.remove('/tmp/temp.xml')
        # traverse through all ports found
        for h in tree.findall('host'):
            for ps in h.findall('ports'):
                for p in ps.findall('port'):
                    # find port information to create Port object
                    portID = p.attrib['portid']
                    transportProtocol = p.attrib['protocol']
                    for st in p.findall('state'):
                        state = st.attrib['state']
                    for sv in p.findall('service'):
                        service = {'name': sv.attrib['name']}
                    # create a new Port object
                    port = Port(portID, transportProtocol, state, service)
                    # append Port to the list of ports found
                    ports.append(port)
        # print ports list
        print(self.sep, '\n* Ports found:\n')
        pprint.pprint(ports)
        print(self.sep)
        # update list of ports
        self.ports = ports

    def getVersions(self):
        ''' run a version (-sV) port scan on open ports list and an OS detection scan (-O) for given ip address and return dictionary '''
        # create a comma-separated list of ports self.ports
        joinPorts = [i.portid for i in self.ports]
        commaPorts = ','.join(joinPorts)
        # create a xml file to parse for results
        scanfile = '/tmp/temp.xml'
        # create a subprocess and connect to pipe, passing in ports list to aggressively scan
        scan2 = subprocess.call(
            'nmap -T4 -sV -O -p{} {} -oX {} > /dev/null'.format(commaPorts, self.ip, scanfile), shell=True)
        # parse temp xml file
        tree = xml.etree.ElementTree.parse(scanfile)
        # remove temporary xml file created (cleanup)
        os.remove('/tmp/temp.xml')
        # traverse through all ports found
        for h in tree.findall('host'):
            # loop through os matches
            for o in h.findall('os'):
                for om in o.findall('osmatch'):
                    match = om.attrib['name']
                # update self.os with the OS found
                self.os = match
            # loop through ports to get version info
            for ps in h.findall('ports'):
                for p in ps.findall('port'):
                    # save the port number
                    portID = p.attrib['portid']
                    srv = {}
                    # collect dictionary of service information
                    for sv in p.findall('service'):
                        for a in ('name', 'product', 'version', 'extrainfo'):
                            if a in sv.attrib:
                                srv[a] = sv.attrib[a]
                    # update ports service attribute in self.ports list with new inf
                    for i in self.ports:
                        if i.portid == portID:
                            i.service = srv

        # TODO - do further version scanning on well-known ports
        # create dictionary or port numbers to metasploit module scanners
        versionScanners = {
            '21': 'ftp',
            '22': 'ssh',
            '23': 'telnet',
            '25': 'smtp',
            '53': 'dns - udp',
            '69': 'tftp - udp'
            '80': 'http',
            '110': 'pop3',
            '119': 'nntp',
            '123': 'ntp',
            '143': 'imap',
            '139': 'use auxiliary/scanner/smb/smb_version; set RHOSTS {}; run'
            '161': 'snmp',
            '194': 'irc',
            '443': 'https and vmware',
            '445': 'smb',
            '1433': 'mssql',
            '3306', 'mysql',
            '5800': 'vnc',
            '5900': 'vnc'
        }

        # print updated ports with services in use and OS found
        print('\n' + self.sep, '\n* Versions and OS found:\n')
        print('OS => ', self.os, '\n')
        for i in self.ports:
            print(i.portid, i.service)
        print(self.sep)

    #     # run searchsploitLookup to print out possible vulnerabilities for each service version found
    #     searchsploitLookup(versions)

    # def searchsploitLookup(versions):
    #     ''' search for vulnerabilities using searchsploit given versions list '''
    #     # filter out OS from ports/versions in dictionary for searches
    #     searches = {}
    #     for i, j in versions.items():
    #         if i.isnumeric():
    #             # create a search string
    #             search = j['name']
    #             # if 'product' in j:
    #             #     print(j['product'])

    #             if 'version' in j and 'product' in j:
    #                 search += ', ' + j['product'] + ' ' + j['version']
    #             elif 'version' in j:
    #                 search += ' ' + j['version']
    #             elif 'product' in j:
    #                 search += ' ' + j['product']

    #             # add search string to searches dict
    #             searches[i] = search

    #         else:
    #             # create a search string for the OS
    #             os = versions[i]

    #     pprint.pprint(searches)
    #     # print('os')
    #     # pprint.pprint(os)

    #     # TODO - use searchsploit to lookup OS exploits
if __name__ == "__main__":
    '''
    if len(sys.argv) == 2:
        # if arg1 is present then check if IP address
        # TODO
        print(sys.argv[1])

        # TODO - check if the user has sudo permissions so they can run OS scan

    else:
        # else print usage
        usage = 'Usage: %s [ip_address]' % (sys.argv[0])
        print(usage)
    '''

    ip = '192.168.1.115'
    ip2 = '192.168.1.80'
    # a = allPortScan(ip)
    # x = versionScan(ip2, ['80'])
    # y = versionScan(ip, ['22', '80', '111', '139', '443', '32768'])
    # b = versionScan(ip2, ['80'])

    t1 = Target(ip)
    t1.getPorts()

    t1.getVersions()
