'''
port scanning automation tool used on the command line
1) run a port scan on all ports
input: ip address
output:
    a) list of open ports to scan further
    b) list of filtered ports to scan further to use
2) run an nmap version scan against ports found to use
input:  list of open ports
output:
    a) print dictionary of results (i.e. port : [service, version, vulns])
    b) list of versions to use
3) use searchsploit to find vulnerabilities based on version used
input: list of versions
output: print dictionary of possible vulnerabilities (i.e. version : [vuln1, ...])
*** this is like scanner_v2.py (version 2), but use a Port class to keep track of ports and add information as you go

also included is a findTargets function which performs a ping sweep to find possible targets on the network
'''
# modules required
import sys
import os
import subprocess
import xml.etree.ElementTree
import pprint
import json
import re

''' ****************************************************************** '''
''' ********************** classes *********************************** '''
''' ****************************************************************** '''


class Port:
    ''' a class for each Port found in a port scan '''

    def __init__(self, portid, transport_protocol, state, service):
        self.portid = portid
        self.transport_protocol = transport_protocol
        self.state = state
        self.service = service
        self.vulnerabilities = {}

    def __str__(self):
        return self.portid

    def __repr__(self):
        return '{} : {}'.format(self.portid, self.service['name'])


class Target:
    ''' a class for each Target of a port scan '''
    # separator value to use when printing output
    sep = '=' * 60

    def __init__(self, ip):
        self.ip = ip
        self.ports = []
        self.os = ''
        self.hostname = ''
        self.state = ''

    def pingCheck(self):
        ''' run an nmap ping scan on the target to see if it responds to ping requests '''
        # create a xml file to parse for results
        scanfile = '/tmp/temp.xml'
        # create a subprocess and run nmap command
        pnScan = subprocess.call(
            'nmap -sn {} -oX {} > /dev/null'.format(self.ip, scanfile), shell=True)
        # parse temp xml file
        tree = xml.etree.ElementTree.parse(scanfile)
        # remove temporary xml file created (cleanup)
        os.remove('/tmp/temp.xml')
        # traverse through all host found
        for h in tree.findall('host'):
            # get the status of the IP address (up or down)
            for s in h.findall('status'):
                self.state = s.attrib['state']
            # get the hostname of the IP address (if there is one, else leave blank)
            for hns in h.findall('hostnames'):
                for hn in hns.findall('hostname'):
                    self.hostname = hn.attrib['name']
        # return True if the host is up and live (responding to pings)
        if self.state == 'up':
            return True
        else:
            return False

    def getPorts(self):
        ''' run an nmap TCP port scan on all ports for given ip address '''
        # create a xml file to parse for results
        scanfile = '/tmp/temp.xml'
        # create a subprocess and run nmap command
        pScan = subprocess.call(
            'nmap -T4 -p- {} -oX {} > /dev/null'.format(self.ip, scanfile), shell=True)
        # parse temp xml file
        tree = xml.etree.ElementTree.parse(scanfile)
        # create a list of port objects
        ports = []
        # remove temporary xml file created (cleanup)
        os.remove('/tmp/temp.xml')
        # traverse through all ports found
        for h in tree.findall('host'):
            for ps in h.findall('ports'):
                for p in ps.findall('port'):
                    # find port information to create Port object
                    portID = p.attrib['portid']
                    transportProtocol = p.attrib['protocol']
                    for st in p.findall('state'):
                        state = st.attrib['state']
                    for sv in p.findall('service'):
                        service = {'name': sv.attrib['name']}
                    # create a new Port object
                    port = Port(portID, transportProtocol, state, service)
                    # append Port to the list of ports found
                    ports.append(port)
        # update list of ports
        self.ports = ports
        # print ports list
        print(self.sep, '\n* Ports found:\n')
        for i in self.ports:
            print('\t', i.portid, i.service)
        print('\n* Hostname found:\t' + self.hostname + '\n')
        print(self.sep)

    def getVersions(self):
        ''' run a version (-sV) port scan on open ports list and an OS detection scan (-O) for given ip address and return dictionary '''
        # create a comma-separated list of ports self.ports
        joinPorts = [i.portid for i in self.ports]
        commaPorts = ','.join(joinPorts)
        # create a xml file to parse for results
        scanfile = '/tmp/temp.xml'
        # create a subprocess and connect to pipe, passing in ports list to aggressively scan
        vScan = subprocess.call(
            'nmap -T4 -sV -O -p{} {} -oX {} > /dev/null'.format(commaPorts, self.ip, scanfile), shell=True)
        # parse temp xml file
        tree = xml.etree.ElementTree.parse(scanfile)
        # remove temporary xml file created (cleanup)
        os.remove('/tmp/temp.xml')
        # traverse through all ports found
        for h in tree.findall('host'):
            # loop through os matches
            for o in h.findall('os'):
                for om in o.findall('osmatch'):
                    match = om.attrib['name']
                # update self.os with the OS found
                self.os = match
            # loop through ports to get version info
            for ps in h.findall('ports'):
                for p in ps.findall('port'):
                    # save the port number
                    portID = p.attrib['portid']
                    srv = {}
                    # collect dictionary of service information
                    for sv in p.findall('service'):
                        for a in ('name', 'product', 'version', 'extrainfo'):
                            if a in sv.attrib:
                                srv[a] = sv.attrib[a]
                    # update ports service attribute in self.ports list with new inf
                    for i in self.ports:
                        if i.portid == portID:
                            i.service = srv

        # TODO - do further version scanning on well-known ports
        # create dictionary or port numbers to metasploit module scanner commands
        versionScanners = {
            '21': 'ftp',
            '22': 'use auxiliary/scanner/ssh/ssh_version; set RHOSTS {}; run',
            '23': 'telnet',
            '25': 'smtp',
            '53': 'dns - udp',
            '69': 'tftp - udp',
            '80': 'http',
            '110': 'pop3',
            '119': 'nntp',
            '123': 'ntp',
            '143': 'imap',
            '139': 'use auxiliary/scanner/smb/smb_version; set RHOSTS {}; run',
            '161': 'snmp',
            '194': 'irc',
            '443': 'https and vmware',
            '445': 'smb',
            '1433': 'mssql',
            '3306': 'mysql',
            '5800': 'vnc',
            '5900': 'vnc'
        }

        # print updated ports with services in use and OS found
        print('\n' + self.sep, '\n* OS found:\t' + self.os)
        print('\n* Versions found:\n')
        for i in self.ports:
            print(i.portid, i.service)
        print(self.sep + '\n')

    # TODO - use version information to search searchsploit for vulnerabilities
    def getVulns(self):
        ''' search for vulnerabilities using searchsploit given versions list '''
        # create a list of searches to perform
        searches = []
        for i in self.ports:
            search = {'s_str': None, 's_result': None}
            srvs = ' '.join(i.service.values())
            search['s_str'] = srvs
            searches.append(search)

        pprint.pprint(searches)


''' ****************************************************************** '''
''' ************************** functions ***************************** '''
''' ****************************************************************** '''


def findTargets(ipRange):
    ''' function to identify possible targets on an IP range '''
    # create a xml file to parse for results
    scanfile = '/tmp/temp.xml'
    # create a subprocess and run nmap command
    fScan = subprocess.call(
        'nmap -sn {} -oX {} > /dev/null'.format(ipRange, scanfile), shell=True)
    # parse temp xml file
    tree = xml.etree.ElementTree.parse(scanfile)
    # create a list of hosts found on subnet
    addresses = []
    # remove temporary xml file created (cleanup)
    os.remove('/tmp/temp.xml')
    # traverse through all host found
    for h in tree.findall('host'):
        for a in h.findall('address'):
            addresses.append(a.attrib['addr'])

    hosts = {k: v for (k, v) in enumerate(addresses, 1)}

    return hosts


if __name__ == "__main__":

    ''' ****************************************************************** '''
    ''' *************** functions when used as script ******************** '''
    ''' ****************************************************************** '''
    # user actions that could be taken are broken into functions for ease-of-use - results can be collated here also
    def portScan(target):
        print('You selected "Port Scan" ... initiating')
        target.getPorts()

    def versionScan(target):
        print('You selected "Version Scan" ... initiating')
        # check if the user has sudo permissions so they can run OS scan, by checking if their 'effective' uid is 0 (root)
        if os.geteuid() != 0:
            print("You need to have root privileges to run this script.\nPlease try again, this time using 'sudo'. Exiting.")
            sys.exit(0)
        # execute getPorts and getVersions methods to return versions running on ports
        target.getPorts()
        target.getVersions()

    def vulnScan(target):
        print('You selected "Vulnerability Scan" ... initiating')
        # check if the user has sudo permissions so they can run OS scan, by checking if their 'effective' uid is 0 (root)
        if os.geteuid() != 0:
            print("You need to have root privileges to run this script.\nPlease try again, this time using 'sudo'. Exiting.")
            sys.exit(0)
        target.getPorts()
        target.getVersions()
        target.getVulns()

    # interactive user interface component
    def ip_interface(ip):
        # create Target object
        t1 = Target(sys.argv[1])
        # check if IP address is live by doing pinging the target
        print('Performing ping check to see if the host is live')
        test = t1.pingCheck()
        if test:
            # host is live
            print('* Host is live ... select action to take:')
            # get what scan a user wants to perform and loop until valid selection is made
            while True:
                selection = input(
                    '1 - Port Scan\n2 - Version Scan\n3 - Vulnerability Scan\n=> ')
                # call the correct function to run commands required based on input
                if selection == '1':
                    portScan(t1)
                    break
                elif selection == '2':
                    versionScan(t1)
                    break
                elif selection == '3':
                    vulnScan(t1)
                    break
                else:
                    print('Invalid selection ... please try again')
        else:
            # else host is not live, so exit
            print('Host is down ... unable to perform further action at this time')
            sys.exit(0)

    ''' ****************************************************************** '''
    ''' ********************* main code for script *********************** '''
    ''' ****************************************************************** '''
    # check if arg 1 is present
    if len(sys.argv) == 2:
        # check if arg is ip range or single ip (if it contains a / or - with numbers or a hostname - nmap specification)
        if '/' in sys.argv[1] or '-' in sys.argv[1]:
            # if ip range call findTargets with ip_range -> returns a dictionary of numbers and live IPs
            ip_range = sys.argv[1]
            print(
                '\nYou entered an address range - performing ping sweep to find targets...')
            targets = findTargets(ip_range)
            # get user to select a target from the dictionary
            while True:
                print('* Targets found - please select one:\n')
                for k, v in targets.items():
                    print('\t{} -> {}'.format(k, v))
                s = input('=> ')
                selection = int(s)
                if selection in targets:
                    ip_target = targets[selection]
                    ip_interface(ip_target)
                    break
                else:
                    print('\nInvalid selection. Please try again.')
        else:
            # else ip is a single IP address or hostname - call interface with single ip
            ip_interface(ip_target)

    else:
        # else print usage
        usage = 'Usage: %s [ip_address]' % (sys.argv[0])
        print(usage)
