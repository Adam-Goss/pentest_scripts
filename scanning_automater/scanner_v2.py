'''
port scanning automation tool used on the command line
1) run a port scan on all ports
input: ip address
output:
    a) list of open ports to scan further
    b) list of filtered ports to scan further to use
2) run an nmap version scan against ports found to use
input:  list of open ports
output:
    a) print dictionary of results (i.e. port : [service, version, vulns])
    b) list of versions to use
3) use searchsploit to find vulnerabilities based on version used
input: list of versions
output: print dictionary of possible vulnerabilities (i.e. version : [vuln1, ...])
*** this is like scanner.py (version 1), but parses xml output from nmap for better results
'''
import sys
import os
import re
import subprocess
import xml.etree.ElementTree
import pprint


def allPortScan(ip):
    ''' run an nmap TCP port scan on all ports for given ip address '''
    # create a xml file to parse for results
    scanfile = '/tmp/temp.xml'
    # create a subprocess and run nmap command
    scan = subprocess.call(
        'nmap -T4 -p- {} -oX {} > /dev/null'.format(ip, scanfile), shell=True)
    # parse temp xml file
    tree = xml.etree.ElementTree.parse(scanfile)
    # remove temporary xml file created (cleanup)
    os.remove('/tmp/temp.xml')
    # create a dictionary of open, closed, filtered ports
    ports = {'open': [], 'closed': [], 'filtered': []}
    # traverse through all ports found
    for h in tree.findall('host'):
        for ps in h.findall('ports'):
            for p in ps.findall('port'):
                # save the port number
                portNum = p.attrib['portid']
                print(portNum)
                # append port to corrent list in ports dictionary
                for st in p.findall('state'):
                    if st.attrib['state'] == 'open':
                        ports['open'].append(portNum)
                    elif st.attrib['state'] == 'closed':
                        ports['closed'].append(portNum)
                    elif st.attrib['state'] == 'filtered':
                        ports['filtered'].append(portNum)

    # print open, closed, filtered ports dictionary
    pprint.pprint(ports)
    # run the version scan on open ports found
    # versionScan(ip, ports['open'])


def versionScan(ip, ports):
    ''' run a version (-sV) port scan on open ports list and an OS detection scan (-O) for given ip address and return dictionary '''
    # create a comma-separated list of ports from passed in ports
    commaPorts = ','.join(ports)
    # create a xml file to parse for results
    scanfile = '/tmp/temp.xml'
    # create a subprocess and connect to pipe, passing in ports list to aggressively scan
    scan = subprocess.call(
        'nmap -T4 -sV -O -p{} {} -oX {} > /dev/null'.format(commaPorts, ip, scanfile), shell=True)
    # parse temp xml file
    tree = xml.etree.ElementTree.parse(scanfile)
    # remove temporary xml file created (cleanup)
    os.remove('/tmp/temp.xml')
    # create dictionary of port => software version running
    versions = {}
    # traverse through all ports found
    for h in tree.findall('host'):
        # loop through os matches

        # TODO: FIX OS MATCH LOOP THROUGH AND DICTIONARY ASSIGNMENT

        for o in h.findall('os'):
            matches = []
            for om in o.findall('osmatch'):
                match = {
                    'name': om.attrib['name'],
                    'accuracy': om.attrib['accuracy']
                }
                matches.append(match)
            # update versions dictionary with possible os matches
            versions['os'] = matches
        # loop through ports to get version info
        for ps in h.findall('ports'):
            for p in ps.findall('port'):
                # save the port number
                portNum = p.attrib['portid']
                # collect dictionary of service information
                for sv in p.findall('service'):
                    srv = {}
                    for a in ('name', 'product', 'version', 'extrainfo'):
                        if a in sv.attrib:
                            srv[a] = sv.attrib[a]

                # update versions dictionary with entry
                versions[portNum] = srv

    # print versions dictionary of dictionaries
    pprint.pprint(versions)

    # run searchsploitLookup to print out possible vulnerabilities for each service version found
    # searchsploitLookup(versions)


def searchsploitLookup(versions):
    ''' search for vulnerabilities using searchsploit given versions list '''


if __name__ == "__main__":
    '''
    if len(sys.argv) == 2:
        # if arg1 is present then check if IP address
        # TODO 
        print(sys.argv[1])

    else:
        # else print usage 
        usage = 'Usage: %s [ip_address]' % (sys.argv[0])
        print(usage)
    '''

    ip = '192.168.1.80'

    # x = allPortScan(ip)

    y = versionScan(ip, ['22', '80', '111', '139', '443', '32768'])
    # print(x)
