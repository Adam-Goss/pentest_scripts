'''
port scanning automation tool used on the command line
1) run a port scan on all ports
input: ip address
output:
    a) list of open ports to scan further
    b) list of filtered ports to scan further to use
2) run an nmap version scan against ports found to use
input:  list of open ports
output:
    a) print dictionary of results (i.e. port : [service, version, vulns])
    b) list of versions to use
3) use searchsploit to find vulnerabilities based on version used
input: list of versions
output: print dictionary of possible vulnerabilities (i.e. version : [vuln1, ...])
*** this is like scanner.py (version 1), but parses xml output from nmap for better results
'''
# modules required
import sys
import os
import subprocess
import xml.etree.ElementTree
import pprint
import json

# separator value to use when printing output
sep = '=' * 60


def allPortScan(ip):
    ''' run an nmap TCP port scan on all ports for given ip address '''
    # create a xml file to parse for results
    scanfile = '/tmp/temp.xml'
    # create a subprocess and run nmap command
    scan = subprocess.call(
        'nmap -T4 -p- {} -oX {} > /dev/null'.format(ip, scanfile), shell=True)
    # parse temp xml file
    tree = xml.etree.ElementTree.parse(scanfile)
    # remove temporary xml file created (cleanup)
    os.remove('/tmp/temp.xml')
    # create a dictionary of open, closed, filtered ports
    ports = {'open': [], 'closed': [], 'filtered': []}
    # traverse through all ports found
    for h in tree.findall('host'):
        for ps in h.findall('ports'):
            for p in ps.findall('port'):
                # save the port number
                portNum = p.attrib['portid']
                # append port to corrent list in ports dictionary
                for st in p.findall('state'):
                    if st.attrib['state'] == 'open':
                        ports['open'].append(portNum)
                    elif st.attrib['state'] == 'closed':
                        ports['closed'].append(portNum)
                    elif st.attrib['state'] == 'filtered':
                        ports['filtered'].append(portNum)

    # print open, closed, filtered ports dictionary
    print(sep, '\n* Ports found:\n')
    pprint.pprint(ports)
    print(sep)
    # run the version scan on open ports found
    versionScan(ip, ports['open'])


def versionScan(ip, ports):
    ''' run a version (-sV) port scan on open ports list and an OS detection scan (-O) for given ip address and return dictionary '''
    # create a comma-separated list of ports from passed in ports
    commaPorts = ','.join(ports)
    # create a xml file to parse for results
    scanfile = '/tmp/temp.xml'
    # create a subprocess and connect to pipe, passing in ports list to aggressively scan
    scan = subprocess.call(
        'nmap -T4 -sV -O -p{} {} -oX {} > /dev/null'.format(commaPorts, ip, scanfile), shell=True)
    # parse temp xml file
    tree = xml.etree.ElementTree.parse(scanfile)
    # remove temporary xml file created (cleanup)
    os.remove('/tmp/temp.xml')
    # create dictionary of port => software version running
    versions = {}
    # traverse through all ports found
    for h in tree.findall('host'):
        # loop through os matches
        for o in h.findall('os'):
            for om in o.findall('osmatch'):
                match = {
                    'name': om.attrib['name'],
                    'accuracy': om.attrib['accuracy']
                }
            # update versions dictionary with possible os matches
            versions['os'] = match
        # loop through ports to get version info
        for ps in h.findall('ports'):
            for p in ps.findall('port'):
                # save the port number
                portNum = p.attrib['portid']
                # collect dictionary of service information
                for sv in p.findall('service'):
                    srv = {}
                    for a in ('name', 'product', 'version', 'extrainfo'):
                        if a in sv.attrib:
                            srv[a] = sv.attrib[a]

                # update versions dictionary with entry
                versions[portNum] = srv

    # TODO - sort out all ports that do have a version and those that don't for further version scanning using Metasploit

    # print versions dictionary of dictionaries
    print('\n' + sep, '\n* Versions and OS found:\n')
    pprint.pprint(versions)
    print(sep)

    # run searchsploitLookup to print out possible vulnerabilities for each service version found
    searchsploitLookup(versions)


def searchsploitLookup(versions):
    ''' search for vulnerabilities using searchsploit given versions list '''
    # filter out OS from ports/versions in dictionary for searches
    searches = {}
    for i, j in versions.items():
        if i.isnumeric():
            # create a search string
            search = j['name']
            # if 'product' in j:
            #     print(j['product'])

            if 'version' in j and 'product' in j:
                search += ', ' + j['product'] + ' ' + j['version']
            elif 'version' in j:
                search += ' ' + j['version']
            elif 'product' in j:
                search += ' ' + j['product']

            # add search string to searches dict
            searches[i] = search

        else:
            # create a search string for the OS
            os = versions[i]

    pprint.pprint(searches)
    # print('os')
    # pprint.pprint(os)

    # TODO - use searchsploit to lookup OS exploits


if __name__ == "__main__":
    '''
    if len(sys.argv) == 2:
        # if arg1 is present then check if IP address
        # TODO 
        print(sys.argv[1])

        # TODO - check if the user has sudo permissions so they can run OS scan

    else:
        # else print usage 
        usage = 'Usage: %s [ip_address]' % (sys.argv[0])
        print(usage)
    '''

    ip = '192.168.1.115'

    ip2 = '192.168.1.80'

    # a = allPortScan(ip)
    # x = versionScan(ip2, ['80'])

    y = versionScan(ip, ['22', '80', '111', '139', '443', '32768'])
    # b = versionScan(ip2, ['80'])
